package com.malware.server;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.jdo.PersistenceManager;

import com.malware.common.dto.ServerRequest;
import com.malware.common.dto.ServerResponse;
import com.malware.common.dto.Trip;
import com.malware.common.dto.ServerRequest.ServerMethod;
import com.malware.common.dto.ServerResponse.ResponseCode;

/**
 * This class stores information about a new user into the database.
 */
public class StoreTripMethod {

	public static ServerResponse execute(ServerRequest serverRequest) {
		assert serverRequest.getServerMethod() == ServerMethod.STORE_TRIP;
		
		ServerResponse serverResponse = new ServerResponse();
		
		// Get the current trip from the request.
		Trip currentTrip = serverRequest.getTrip();
		
		// Get all the current trips from the DB.
		List<Trip> allTrips = CommonDataAccessMethods.getAllTrips();
		
		// Go through the trip.
		if (currentTrip.isDriverTrip()) {
			// If it is a driver then fill in some passengers and
			// send the filled in object back to him.
			Trip closestTrip = getClosestTripType1(currentTrip, allTrips);
			
			if (closestTrip != null) {
				List<String> passengerEmails = new ArrayList<String>();
				passengerEmails.add(closestTrip.getUserEmailAddress());	
				currentTrip.setPassengerEmailAddresses(passengerEmails);
			
				Trip newCurrentTrip = storeTrip(currentTrip);
			
				closestTrip.setAssigned(true);
				closestTrip.setAssignedTo(newCurrentTrip.getId());
			
				storeTrip(closestTrip);
			
				List<Trip> returnTrip = new ArrayList<Trip>();
				returnTrip.add(newCurrentTrip);
				serverResponse.setTrips(returnTrip);
			} else {
				storeTrip(currentTrip);
				
				List<Trip> returnTrip = new ArrayList<Trip>();
				returnTrip.add(currentTrip);
				serverResponse.setTrips(returnTrip);
			}
		} else {
			// If it is a rider trip then find suitable trips
			// and return a new trip object with that information filled in.
			Trip closestTrip = getClosestTripType2(currentTrip, allTrips);
			
			currentTrip.setAssigned(true);
			currentTrip.setAssignedTo(closestTrip.getId());
			
			List<String> passengerEmails = closestTrip.getPassengerEmailAddresses();
			passengerEmails.add(currentTrip.getUserEmailAddress());
			
			storeTrip(closestTrip);
			storeTrip(currentTrip);
			
			List<Trip> returnTrip = new ArrayList<Trip>();
			returnTrip.add(closestTrip);
			serverResponse.setTrips(returnTrip);	
		}
		
		// Go through the trip.
		// If it is a rider trip then find suitable trips
		// and return a new trip object with that information filled in.
		
		// If it is a driver then fill in some passengers and
		// send the filled in object back to him.
		
		serverResponse.setResponseCode(ResponseCode.SUCCESS);
		
		return serverResponse;
	}
	
	static double FRACTION = 1;
	
	private static Trip getClosestTripType2(Trip currentTrip, List<Trip> trips) {
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (!trips.get(i).isDriverTrip()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(currentTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	private static Trip getClosestTripType1(Trip currentTrip, List<Trip> trips) {
		
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (trips.get(i).isDriverTrip()) {
				continue;
			}
			if (trips.get(i).isAssigned()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(currentTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	private static boolean isTimeInRange(Trip trip1, Trip trip2) {
		// TODO: Here we compute the distance of the trip.
		// and appropriately check.
		Date time1 = new Date(110, 3, 11, 11, 30);
		Date time2 = new Date(110, 3, 11, 12, 30);
		long timeDiff = time2.getTime() - time1.getTime();
		
		if (Math.abs(trip1.getStartDateTime() - trip2.getStartDateTime()) <= timeDiff) {
			return true;
		} else {
			return false;
		}
	}
	
	private static double getDistanceOfTrip(Trip trip) {
		return Math.abs((trip.getSourceLat() - trip.getDestinationLat())) + 
		       Math.abs((trip.getSourceLng() - trip.getDestinationLng()));	
	}
	
	private static double distanceBetween(Trip trip1, Trip trip2) {
		return distanceBetweenDestinations(trip1, trip2) +
		       distanceBetweenSources(trip1, trip2);
	}
	
	private static double distanceBetweenDestinations(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getDestinationLat() - trip2.getDestinationLat())) + 
			   Math.abs((trip1.getDestinationLng() - trip2.getDestinationLng()));  
	}
	
	private static double distanceBetweenSources(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getSourceLat() - trip2.getSourceLat())) + 
			   Math.abs((trip1.getSourceLng() - trip2.getSourceLng()));  
	}
	
	private static Trip storeTrip(Trip trip) {
		PersistenceManager pm = PMF.get().getPersistenceManager();
		
		Trip returnValue = pm.makePersistent(trip);
		
		pm.close();
		
		return returnValue;
	}
}
