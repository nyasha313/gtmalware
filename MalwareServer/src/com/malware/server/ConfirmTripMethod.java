package com.malware.server;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.jdo.PersistenceManager;
import javax.jdo.Transaction;

import com.malware.common.dto.ServerRequest;
import com.malware.common.dto.ServerResponse;
import com.malware.common.dto.Trip;
import com.malware.common.dto.ServerRequest.ServerMethod;
import com.malware.common.dto.ServerResponse.ResponseCode;

/**
 * This class stores information about a new user into the database.
 */
public class ConfirmTripMethod {

	public static ServerResponse execute(ServerRequest serverRequest) {
		assert serverRequest.getServerMethod() == ServerMethod.CONFIRM_TRIP;
		
		ServerResponse serverResponse = new ServerResponse();
		
		// Get the current trip from the request.
		Trip currentTrip = serverRequest.getUsersTrip();
		
		List<Trip> confirmWithTrips = serverRequest.getConfirmedWithTrips();
		
		// Go through the trip.
		if (currentTrip.isDriverTrip()) {
			// If it is a driver then fill in all the passengers he selected.
			currentTrip = CommonDataAccessMethods.getTrip(currentTrip.getId());
			List<String> passengerEmails = currentTrip.getPassengerEmailAddresses();
			for (int i = 0; i < confirmWithTrips.size(); ++i) {
				Trip passengerTrip = CommonDataAccessMethods.getTrip(confirmWithTrips.get(i).getId());
				
				passengerTrip.setAssigned(true);
				passengerTrip.setAssignedTo(currentTrip.getId());
				
				storeTrip(passengerTrip);
				
				passengerEmails.add(passengerTrip.getUserEmailAddress());
			}
			
			storeTrip(currentTrip);
		} else {
			// If it is a rider trip then add him to that carpool.
			currentTrip = CommonDataAccessMethods.getTrip(currentTrip.getId());
			
			// Get the drivers trip.
			assert confirmWithTrips.size() == 1;
			
			Trip driverTrip = CommonDataAccessMethods.getTrip(confirmWithTrips.get(0).getId());
			
			currentTrip.setAssigned(true);
			currentTrip.setAssignedTo(driverTrip.getId());
			
			List<String> passengerEmails = driverTrip.getPassengerEmailAddresses();
			passengerEmails.add(currentTrip.getUserEmailAddress());
			
			storeTrip(currentTrip);
			storeTrip(driverTrip);
		}
		
		serverResponse.setResponseCode(ResponseCode.SUCCESS);
		
		return serverResponse;
	}
	
	static double FRACTION = 1;
	
	private static Trip getClosestTripType2(Trip currentTrip, List<Trip> trips) {
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (!trips.get(i).isDriverTrip()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestTrip == null) {
			return null;
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(closestTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	private static Trip getClosestTripType1(Trip currentTrip, List<Trip> trips) {
		
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (trips.get(i).isDriverTrip()) {
				continue;
			}
			if (trips.get(i).isAssigned()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(currentTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	private static boolean isTimeInRange(Trip trip1, Trip trip2) {
		// TODO: Here we compute the distance of the trip.
		// and appropriately check.
		Date time1 = new Date(110, 3, 11, 11, 30);
		Date time2 = new Date(110, 3, 11, 12, 30);
		long timeDiff = time2.getTime() - time1.getTime();
		
		if (Math.abs(trip1.getStartDateTime() - trip2.getStartDateTime()) <= timeDiff) {
			return true;
		} else {
			return false;
		}
	}
	
	private static double getDistanceOfTrip(Trip trip) {
		return Math.abs((trip.getSourceLat() - trip.getDestinationLat())) + 
		       Math.abs((trip.getSourceLng() - trip.getDestinationLng()));	
	}
	
	private static double distanceBetween(Trip trip1, Trip trip2) {
		return distanceBetweenDestinations(trip1, trip2) +
		       distanceBetweenSources(trip1, trip2);
	}
	
	private static double distanceBetweenDestinations(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getDestinationLat() - trip2.getDestinationLat())) + 
			   Math.abs((trip1.getDestinationLng() - trip2.getDestinationLng()));  
	}
	
	private static double distanceBetweenSources(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getSourceLat() - trip2.getSourceLat())) + 
			   Math.abs((trip1.getSourceLng() - trip2.getSourceLng()));  
	}
	
	private static Trip storeTrip(Trip trip) {
		PersistenceManager pm = PMF.get().getPersistenceManager();
		
	    final Transaction tx = pm.currentTransaction();
	    Trip returnValue = null;
	    
	    try {
	    	tx.begin();
	    	returnValue = pm.makePersistent(trip);
	    	tx.commit();
	    } catch (Exception e) {
	    	System.out.println(e);
	    } finally {
	    	if (tx.isActive()) {
	    		tx.rollback(); 
	    	}
	    	pm.close();
	    }
		return returnValue;
	}
}
