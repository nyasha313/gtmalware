package com.malware.server;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.jdo.PersistenceManager;
import javax.jdo.Transaction;

import com.malware.common.dto.ServerRequest;
import com.malware.common.dto.ServerResponse;
import com.malware.common.dto.Trip;
import com.malware.common.dto.ServerRequest.ServerMethod;
import com.malware.common.dto.ServerResponse.ResponseCode;

/**
 * This class stores information about a new user into the database.
 */
public class StoreTripMethod {

	public static ServerResponse execute(ServerRequest serverRequest, boolean store) {
		assert serverRequest.getServerMethod() == ServerMethod.STORE_TRIP ||
		       serverRequest.getServerMethod() == ServerMethod.MATCH_TRIP;
		
		ServerResponse serverResponse = new ServerResponse();
		
		// Get the current trip from the request.
		Trip currentTrip = serverRequest.getTrip();
		
		// Get all the current trips from the DB.
		List<Trip> allTrips = CommonDataAccessMethods.getAllTrips();
		
		// Go through the trip.
		if (currentTrip.isDriverTrip()) {
			// If it is a driver then fill in some passengers and
			// send the filled in object back to him.
			List<Trip> closestTrips = getTopClosestTripsType1(currentTrip, allTrips, 5);
			if (closestTrips != null && closestTrips.size() > 0) {
				serverResponse.setTrips(closestTrips);
			}
			
//			if (closestTrip != null) {
//				closestTrip = CommonDataAccessMethods.getTrip(closestTrip.getId());
//				
//				List<String> passengerEmails = new ArrayList<String>();
//				passengerEmails.add(closestTrip.getUserEmailAddress());	
//				currentTrip.setPassengerEmailAddresses(passengerEmails);
//			
//				Trip newCurrentTrip = storeTrip(currentTrip);
//			
//				closestTrip.setAssigned(true);
//				closestTrip.setAssignedTo(newCurrentTrip.getId());
//			
//				storeTrip(closestTrip);
//			
//				List<Trip> returnTrip = new ArrayList<Trip>();
//				returnTrip.add(newCurrentTrip);
//				serverResponse.setTrips(returnTrip);
//			} else {
//				storeTrip(currentTrip);
//				
//				List<Trip> returnTrip = new ArrayList<Trip>();
//				returnTrip.add(currentTrip);
//				serverResponse.setTrips(returnTrip);
//			}
			
			if (store) {
				CommonDataAccessMethods.storeTrip(currentTrip);
			}
		} else {
			// If it is a rider trip then find suitable trips
			// and return a new trip object with that information filled in.
			List<Trip> closestTrips = getTopClosestTripsType2(currentTrip, allTrips, 5);
			if (closestTrips != null && closestTrips.size() > 0) {
				serverResponse.setTrips(closestTrips);
			}
			
//			if (closestTrip != null) {
//				closestTrip = CommonDataAccessMethods.getTrip(closestTrip.getId());
//				
//			    currentTrip.setAssigned(true);
//				currentTrips.setAssignedTo(closestTrip.getId());
//			
//				List<String> passengerEmails = closestTrip.getPassengerEmailAddresses();
//				passengerEmails.add(currentTrip.getUserEmailAddress());
//			
//				storeTrip(closestTrip);
//				
//				List<Trip> returnTrip = new ArrayList<Trip>();
//				returnTrip.add(closestTrip);
//				serverResponse.setTrips(returnTrip);
//			}
			
			if (store) {
				CommonDataAccessMethods.storeTrip(currentTrip);
			}
		}
		
		// Go through the trip.
		// If it is a rider trip then find suitable trips
		// and return a new trip object with that information filled in.
		
		// If it is a driver then fill in some passengers and
		// send the filled in object back to him.
		
		serverResponse.setResponseCode(ResponseCode.SUCCESS);
		
		return serverResponse;
	}
	
	static double FRACTION = 1;
	
	// Looking up trips for a rider.
	private static List<Trip> getTopClosestTripsType2(Trip currentTrip, List<Trip> trips, int topNumber) {
		List<Trip> resultTrips = new ArrayList<Trip>();
		List<Trip> copyOfTrips = new ArrayList<Trip>();
		copyOfTrips.addAll(trips);
		for (int i = 0; i < topNumber; ++i) {
			Trip closestTrip = getClosestTripType2(currentTrip, copyOfTrips);
			if (closestTrip == null) break;
			resultTrips.add(closestTrip);
			copyOfTrips.remove(closestTrip);
		}
		return resultTrips;
	}
	
	// Looking up trips for drivers.
	private static List<Trip> getTopClosestTripsType1(Trip currentTrip, List<Trip> trips, int topNumber) {
		List<Trip> resultTrips = new ArrayList<Trip>();
		List<Trip> copyOfTrips = new ArrayList<Trip>();
		copyOfTrips.addAll(trips);
		for (int i = 0; i < topNumber; ++i) {
			Trip closestTrip = getClosestTripType1(currentTrip, copyOfTrips);
			if (closestTrip == null) break;
			resultTrips.add(closestTrip);
			copyOfTrips.remove(closestTrip);
		}
		if (resultTrips.size() > currentTrip.getNumSeatsAvailable()) {
			return resultTrips.subList(0, currentTrip.getNumSeatsAvailable());
		} else {
			return resultTrips;
		}
	}
	
	// Looking up trips for a rider.
	private static Trip getClosestTripType2(Trip currentTrip, List<Trip> trips) {
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (!trips.get(i).isDriverTrip()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			if (trips.get(i).getNumSeatsAvailable() <= 0) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestTrip == null) {
			return null;
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(closestTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	// Looking up trips for drivers.
	private static Trip getClosestTripType1(Trip currentTrip, List<Trip> trips) {
		
		double closestDistance = Double.MAX_VALUE;
		Trip closestTrip = null;
		
		for (int i = 0; i < trips.size(); ++i) {
			if (trips.get(i).isDriverTrip()) {
				continue;
			}
			if (trips.get(i).isAssigned()) {
				continue;
			}
			if (!isTimeInRange(currentTrip, trips.get(i))) {
				continue;
			}
			
			double distance = distanceBetween(currentTrip, trips.get(i)); 
			if (distance < closestDistance) {
				closestDistance = distance;
				closestTrip = trips.get(i);
			}
		}
		
		if (closestDistance < FRACTION * getDistanceOfTrip(currentTrip)) {
			return closestTrip;	
		} else {
			return null;
		}
	}
	
	private static boolean isTimeInRange(Trip trip1, Trip trip2) {
		// TODO: Here we compute the distance of the trip.
		// and appropriately check.
		Date time1 = new Date(110, 3, 11, 11, 30);
		Date time2 = new Date(110, 3, 11, 12, 30);
		long timeDiff = time2.getTime() - time1.getTime();
		
		if (Math.abs(trip1.getStartDateTime() - trip2.getStartDateTime()) <= timeDiff) {
			return true;
		} else {
			return false;
		}
	}
	
	private static double getDistanceOfTrip(Trip trip) {
		return Math.abs((trip.getSourceLat() - trip.getDestinationLat())) + 
		       Math.abs((trip.getSourceLng() - trip.getDestinationLng()));	
	}
	
	private static double distanceBetween(Trip trip1, Trip trip2) {
		return distanceBetweenDestinations(trip1, trip2) +
		       distanceBetweenSources(trip1, trip2);
	}
	
	private static double distanceBetweenDestinations(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getDestinationLat() - trip2.getDestinationLat())) + 
			   Math.abs((trip1.getDestinationLng() - trip2.getDestinationLng()));  
	}
	
	private static double distanceBetweenSources(Trip trip1, Trip trip2) {
		return Math.abs((trip1.getSourceLat() - trip2.getSourceLat())) + 
			   Math.abs((trip1.getSourceLng() - trip2.getSourceLng()));  
	}
}
